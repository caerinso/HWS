# 부모는 하나다.
# 비선형 구조 , 계층 자료구조 ( 가계부 ) --> 상하관계 , 계층관계, ..
# HTMl 과 같은 구조 .. DOM
# 한 개 이상의 노드로 이루어진 유한 집합
# 최상위 노드 ROOT --> 부모가 없는 애들 (젤 위에)
# 단말 노드 leaf --> 자식이 없는 애들 (젤 밑에)
# 중간 노드
# 형제 노드 , 자손 노드, 조상 노드
# 차수 (degree) : 노드에 연결된 자식 노드수
# 높이 : 거리 개념, 경로상에 이르는 거리 --> 트리의 높이 : 단말 노드의 높이
# 이진 트리 : 모든 노드들이 2 개의 서브 트리를 가지는 트리
# 레벨 i 에서 노드 최대 개수 2^i
# 포화 이진 트리 --> 노드가 다 차 있다. Full Binary Tree
# 루트를 1번으로 해서 정해진 위치에 대한 노드 번호를 가진다.
# 완전 이진 트리 --> 마지막 이전 까지의 트리가 포화 이진 트리이다. Complete Binary Tree
# 편향 이진 트리 --> 초ㅣ소의 대수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진다.
# 개 쓸모 없습 !!( 최악 )
# 이진 트리 - 순회(traversal) : 중복되지 않게 전부 방문 -비선형(1:2)이기에 사이클이 없다.
# 따라서 특별한 방식이 필요하다.
# 전위 순회 (부-->자식) VLR , 중위 순회 LVR, 후위 순회 (자식-->부) LRV
#   V
# L   R
# 전위 순회
# 순서..
# 후위 순회
# 사이클 컨셉 .. 단선하나 들어가면 사이클이 된다 -- 트리의 노드 개수 중요하다 .
# 어떤 두 노드의 연결된 경로는 유일한 경로만 존재한다.

V, E = map(int, input().split())
arr = list(map(int, input().split()))
L = [0]*(V + 1)
R = [0]*(V + 1)
P = [0]*(V + 1)

for i in range(0, E*2, 2):
    parent, child = arr[i], arr[i+1]
    if L[parent] == 0:
        L[parent] = child
    else:
        R[parent] = child
    P[child] = parent
print(L)
print(R)

def inorder(v):
    if v == 0:
        return
    # 전위 순회
    inorder(L[v])
    # 중위 순회
    print(v, end=' ')
    inorder(R[v])
    # 후위 순회


inorder(1)






























